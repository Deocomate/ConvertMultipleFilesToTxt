<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>·ª®ng d·ª•ng G·ªôp File (Tailwind - Updated)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // Optional: Customize Tailwind theme if needed
        // tailwind.config = {
        //   theme: {
        //     extend: {
        //       colors: {
        //         primary: '#4a6fa5', // Example custom color
        //       }
        //     }
        //   }
        // }
    </script>
    <style>
        /* Custom scrollbar styles (optional) */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #a1a1a1;
        }

        /* Add subtle focus ring for accessibility */
        *:focus-visible {
            outline: 2px solid #4a6fa5;
            /* Using a specific blue color */
            outline-offset: 2px;
            border-radius: 4px;
            /* Match button radius */
        }

        /* Style for the loading spinner */
        .spinner {
            border: 5px solid #f3f3f3;
            /* Light grey */
            border-top: 5px solid #4a6fa5;
            /* Blue */
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Ensure drop area border style is consistent */
        #dropArea {
            border-width: 3px;
            /* Explicitly set border width */
        }
    </style>
</head>

<body class="bg-gray-100 font-sans antialiased">
    <div class="container mx-auto p-4 md:p-6 lg:p-8 max-w-7xl">
        <div class="flex flex-col md:flex-row gap-4 md:gap-6 lg:gap-8 h-auto md:h-[90vh]">

            <div
                class="panel flex flex-col bg-white rounded-lg shadow-md overflow-hidden md:w-1/2 lg:w-2/5 min-h-[400px] md:min-h-0">
                <div
                    class="panel-header bg-blue-600 text-white p-4 font-bold flex justify-between items-center flex-shrink-0">
                    <span>K√©o th·∫£ files ho·∫∑c folders</span>
                    <button id="clearBtn"
                        class="clear-btn bg-red-500 hover:bg-red-600 text-white text-xs font-bold py-1 px-3 rounded transition duration-200">X√≥a
                        t·∫•t c·∫£</button>
                </div>
                <div id="dropArea"
                    class="drop-area flex-grow border-dashed border-gray-300 p-4 m-4 rounded-lg text-center flex flex-col justify-center items-center text-gray-600 bg-gray-50 transition duration-300 relative overflow-y-auto min-h-[250px]">
                    <div id="dropAreaContent" class="drop-area-content mb-4 flex flex-col items-center">
                        <div class="text-5xl mb-3 text-blue-500">üìÅ</div>
                        <p class="mb-2">K√©o th·∫£ files ho·∫∑c folders v√†o ƒë√¢y</p>
                        <p class="text-sm text-gray-500 mb-3">ho·∫∑c paste (Ctrl+V) t·ª´ File Explorer</p>
                        <p class="mb-3">ho·∫∑c</p>
                        <input type="file" id="fileInput" multiple webkitdirectory directory style="display: none;">
                        <div class="flex flex-col sm:flex-row gap-3 justify-center">
                            <button
                                onclick="document.getElementById('fileInput').setAttribute('webkitdirectory', false); document.getElementById('fileInput').setAttribute('directory', false); document.getElementById('fileInput').click()"
                                class="action-btn bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded transition duration-200">
                                Ch·ªçn Files
                            </button>
                            <button onclick="requestDirectoryAccess()"
                                class="action-btn bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded transition duration-200">
                                Ch·ªçn Folder
                            </button>
                        </div>
                    </div>
                    <div id="fileList" class="file-list w-full text-left mt-4 max-h-[calc(100%-180px)] overflow-y-auto">
                        <p class="text-gray-500 text-sm italic">Ch∆∞a c√≥ file n√†o ƒë∆∞·ª£c ch·ªçn.</p>
                    </div>
                </div>
            </div>

            <div
                class="panel flex flex-col bg-white rounded-lg shadow-md overflow-hidden md:w-1/2 lg:w-3/5 min-h-[400px] md:min-h-0">
                <div class="panel-header bg-blue-600 text-white p-4 font-bold flex-shrink-0">
                    N·ªôi dung g·ªôp
                </div>
                <div class="content-area flex-grow p-4 flex flex-col overflow-hidden">
                    <textarea id="textContent"
                        class="text-content flex-grow p-3 border border-gray-300 rounded-lg text-sm font-mono resize-none outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent overflow-y-auto mb-3"
                        readonly placeholder="N·ªôi dung c·ªßa c√°c file s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y..."></textarea>
                    <div id="stats" class="stats text-xs text-gray-600 text-right mb-3 flex-shrink-0">Files: 0 | T·ªïng
                        k√≠ch th∆∞·ªõc: 0 Bytes | Context: 0 k√Ω t·ª±</div>
                    <div class="button-area flex flex-col sm:flex-row justify-end items-center gap-3 flex-shrink-0">
                        <span id="copySuccess"
                            class="copy-success text-green-600 font-bold text-sm opacity-0 transition-opacity duration-300 order-1 sm:order-none">ƒê√£
                            sao ch√©p!</span>
                        <button id="copyBtn"
                            class="copy-btn bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded transition duration-200 order-2 sm:order-none w-full sm:w-auto">Sao
                            ch√©p n·ªôi dung</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="loading"
        class="loading fixed inset-0 bg-white bg-opacity-80 flex flex-col justify-center items-center z-50 hidden">
        <div class="spinner mb-4"></div>
        <p class="text-gray-700 font-semibold">ƒêang x·ª≠ l√Ω files...</p>
        <p id="loadingStatus" class="text-gray-600 text-sm mt-1"></p>
    </div>

    <script>
        // ===== JavaScript Code (Refactored) =====

        // --- DOM Elements ---
        const dropArea = document.getElementById('dropArea');
        const fileInput = document.getElementById('fileInput');
        const fileList = document.getElementById('fileList');
        const textContent = document.getElementById('textContent');
        const copyBtn = document.getElementById('copyBtn');
        const copySuccess = document.getElementById('copySuccess');
        const clearBtn = document.getElementById('clearBtn');
        const stats = document.getElementById('stats');
        const loading = document.getElementById('loading');
        const loadingStatus = document.getElementById('loadingStatus');
        const dropAreaContent = document.getElementById('dropAreaContent'); // Container for icon/text/buttons

        // --- Constants ---
        const nonTextFileExtensions = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'tiff', 'webp', 'ico', 'heic', 'heif', 'avif', 'icns', 'cur', 'mp3', 'wav', 'aac', 'ogg', 'flac', 'm4a', 'opus', 'mp4', 'mov', 'avi', 'mkv', 'webm', 'flv', 'wmv', 'woff', 'woff2', 'ttf', 'otf', 'eot', 'zip', 'rar', 'tar', 'gz', '7z', 'bz2', 'xz', 'iso', 'img', 'dmg', 'pdf', 'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx', 'odt', 'ods', 'odp', 'key', 'numbers', 'pages', 'exe', 'dll', 'so', 'dylib', 'app', 'msi', 'deb', 'rpm', 'jar', 'db', 'sqlite', 'sqlite3', 'mdb', 'accdb', 'sqlitedb', 'bin', 'dat', 'class', 'pyd', 'pyc', 'pyo', 'o', 'a', 'lib', 'swf', 'psd', 'ai', 'eps', 'lock', 'bak', 'tmp', 'temp', 'swp'];
        const readableMimeTypes = ['text/', 'application/json', 'application/xml', 'application/javascript', 'application/typescript', 'application/x-httpd-php', 'application/x-sh', 'application/xhtml+xml', 'image/svg+xml', 'application/yaml', 'application/toml', 'application/sql', 'application/rtf', 'application/csv', 'application/vnd.mozilla.xul+xml'];
        const commonTextFiles = ['dockerfile', 'makefile', 'readme', 'license', 'authors', 'changelog', 'contributing', 'procfile', 'gemfile', 'rakefile', 'jenkinsfile', 'vagrantfile', 'pipeline', '.env', '.gitattributes', '.gitignore', '.gitmodules', '.npmrc', '.yarnrc', '.npmignore', '.babelrc', '.eslintrc', '.prettierrc', '.editorconfig', '.browserslistrc', 'requirements.txt', 'pipfile', 'go.mod', 'go.sum', 'composer.json', 'package.json', 'tsconfig.json', 'manifest.json', 'config.xml', 'pom.xml', 'build.gradle', 'settings.gradle', 'cmakelists.txt'];
        const defaultIgnoredPatterns = ['.git/', 'node_modules/', 'vendor/', 'bower_components/', 'storage/', 'build/', 'dist/', 'out/', 'target/', '.svn/', '.hg/', '.bzr/', '.idea/', '.vscode/', '.project/', '.settings/', '__pycache__/', '.pytest_cache/', '.mypy_cache/', '.ruff_cache/', 'coverage/', 'logs/', 'tmp/', 'temp/', '*.lockb', '*.log', '*.tmp', '*.bak', '*.swp', '*.DS_Store'];

        // --- State Variables ---
        let files = [];
        let gitignoreRules = [];
        let gitignoreFound = false;
        let rootPath = '';

        // --- Utility Functions ---
        const preventDefaults = (e) => {
            e.preventDefault();
            e.stopPropagation();
        };

        // --- UPDATED highlight/unhighlight functions ---
        const highlight = () => {
            // Remove default state classes
            dropArea.classList.remove('border-gray-300', 'bg-gray-50');
            // Add active state classes (closer to original blue style)
            dropArea.classList.add('border-blue-600', 'bg-blue-600/10'); // Use blue-600 border and 10% opacity blue background
        };
        const unhighlight = () => {
            // Remove active state classes
            dropArea.classList.remove('border-blue-600', 'bg-blue-600/10');
            // Add back default state classes
            dropArea.classList.add('border-gray-300', 'bg-gray-50');
        };
        // --- End of UPDATED highlight/unhighlight ---


        const formatFileSize = (bytes) => {
            if (bytes === 0 || isNaN(bytes)) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.max(0, Math.min(sizes.length - 1, Math.floor(Math.log(bytes) / Math.log(k))));
            return `${parseFloat((bytes / Math.pow(k, i)).toFixed(2))} ${sizes[i]}`;
        };

        const readFileAsync = (file) => {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = (e) => reject(new Error(`L·ªói ƒë·ªçc file: ${e.target.error?.message || 'Kh√¥ng r√µ'}`));
                reader.readAsText(file);
            });
        };

        // --- File Type Checking ---
        const isTextFile = (file) => {
            if (!file || !file.name) return false;
            const fileNameLower = file.name.toLowerCase();
            const extension = fileNameLower.includes('.') ? fileNameLower.split('.').pop() : '';
            if (extension && nonTextFileExtensions.includes(extension)) return false;
            if (file.type) {
                if (readableMimeTypes.some(mime => file.type.startsWith(mime))) return true;
                if (file.type.startsWith('image/') || file.type.startsWith('audio/') || file.type.startsWith('video/') || file.type.startsWith('font/') || file.type.startsWith('application/octet-stream') || file.type.startsWith('application/zip') || file.type.startsWith('application/pdf') || file.type.startsWith('application/msword') || file.type.startsWith('application/vnd.ms-excel') || file.type.startsWith('application/vnd.ms-powerpoint')) return false;
            }
            if (commonTextFiles.includes(fileNameLower)) return true;
            if (fileNameLower.startsWith('.') && commonTextFiles.includes(fileNameLower)) return true;
            if (!extension && !file.type && file.size > 1024) return false;
            return true;
        };

        // --- Gitignore and Folder Ignoring Logic ---
        const parseGitignore = async (file) => {
            try {
                const content = await readFileAsync(file);
                gitignoreRules = content.split('\n').map(line => line.trim()).filter(line => line && !line.startsWith('#')).map(rule => rule.replace(/^\\#/, '#'));
                console.log(`ƒê√£ ƒë·ªçc .gitignore v·ªõi ${gitignoreRules.length} quy t·∫Øc.`);
                gitignoreFound = true;
                return true;
            } catch (error) {
                console.error('L·ªói khi ƒë·ªçc ho·∫∑c ph√¢n t√≠ch file .gitignore:', error);
                gitignoreRules = [];
                gitignoreFound = false;
                return false;
            }
        };

        const matchesIgnorePattern = (path, pattern) => {
            let isNegation = false;
            if (pattern.startsWith('!')) { isNegation = true; pattern = pattern.substring(1); }
            const normalizedPattern = pattern.replace(/^\/+|\/+$/g, '');
            const isDirPattern = pattern.endsWith('/');
            if (path === normalizedPattern || path === normalizedPattern + '/') return !isNegation;
            if (isDirPattern && path.startsWith(normalizedPattern + '/')) return !isNegation;
            if (!pattern.includes('/')) {
                if (pattern.startsWith('*.')) { const ext = pattern.substring(1); if (path.endsWith(ext)) return !isNegation; }
                else if (pattern.endsWith('*')) { const prefix = normalizedPattern.slice(0, -1); if (path.split('/').pop().startsWith(prefix)) return !isNegation; }
                else { if (path.split('/').includes(normalizedPattern)) return !isNegation; }
            }
            if (pattern.includes('/') && !isDirPattern && path === normalizedPattern) return !isNegation;
            return false;
        };

        const isPathIgnored = (relativePath) => {
            if (!relativePath) return false;
            const normalizedPath = relativePath.replace(/^\/+/, '');
            let ignored = false;
            for (const pattern of defaultIgnoredPatterns) { if (matchesIgnorePattern(normalizedPath, pattern)) { ignored = true; break; } }
            if (gitignoreFound) {
                let lastMatchWasIgnore = false; let lastMatchWasInclude = false;
                for (const rule of gitignoreRules) {
                    let currentRule = rule; let isNegationRule = false;
                    if (currentRule.startsWith('!')) { isNegationRule = true; currentRule = currentRule.substring(1); }
                    if (!currentRule) continue;
                    if (matchesIgnorePattern(normalizedPath, rule)) {
                        if (isNegationRule) { lastMatchWasInclude = true; lastMatchWasIgnore = false; }
                        else { lastMatchWasIgnore = true; lastMatchWasInclude = false; }
                    }
                }
                if (lastMatchWasInclude) ignored = false; if (lastMatchWasIgnore) ignored = true;
            }
            return ignored;
        };

        // --- File/Directory Handling (DataTransfer items API - Preferred) ---
        const readDirectoryEntriesRecursive = async (directoryEntry, currentFilesList) => {
            const currentPath = directoryEntry.fullPath;
            if (isPathIgnored(currentPath + '/')) return;
            const reader = directoryEntry.createReader();
            const readEntriesBatch = () => new Promise((resolve, reject) => reader.readEntries(resolve, reject));
            let entries;
            do {
                try {
                    entries = await readEntriesBatch();
                    if (entries.length > 0) {
                        const entryPromises = [];
                        for (const entry of entries) {
                            const entryPath = entry.fullPath;
                            if (entry.isDirectory) { entryPromises.push(readDirectoryEntriesRecursive(entry, currentFilesList)); }
                            else if (entry.isFile) {
                                if (entry.name !== '.gitignore' && !isPathIgnored(entryPath)) {
                                    entryPromises.push(new Promise((resolveFile, rejectFile) => {
                                        entry.file(file => {
                                            try { file.relativePath = entryPath; if (isTextFile(file)) currentFilesList.push(file); resolveFile(); }
                                            catch (fileProcessingError) { console.error(`Error processing file object for ${entryPath}:`, fileProcessingError); rejectFile(fileProcessingError); }
                                        }, (err) => { console.error(`Error getting file object for ${entryPath}:`, err); rejectFile(err); });
                                    }));
                                }
                            }
                        }
                        await Promise.all(entryPromises);
                    }
                } catch (error) { console.error(`Error reading directory entries for ${currentPath}:`, error); break; }
            } while (entries && entries.length > 0);
        };

        const handleDropWithItems = async (items) => {
            showLoading('ƒêang qu√©t files v√† th∆∞ m·ª•c...');
            let collectedFiles = []; let processingPromises = [];
            gitignoreRules = []; gitignoreFound = false; rootPath = '';
            const entries = [];
            for (const item of items) {
                if (item.kind === 'file' && typeof item.webkitGetAsEntry === 'function') entries.push(item.webkitGetAsEntry());
                else if (item.kind === 'file') { const file = item.getAsFile(); if (file) { file.relativePath = '/' + file.name; if (isTextFile(file)) collectedFiles.push(file); } }
            }
            if (entries.length === 0 && collectedFiles.length > 0) { addFiles(collectedFiles); hideLoading(); return; }
            if (entries.length === 0) { console.log("Kh√¥ng t√¨m th·∫•y m·ª•c file/folder h·ª£p l·ªá ƒë·ªÉ x·ª≠ l√Ω."); hideLoading(); return; }
            const firstEntry = entries[0];
            if (firstEntry) {
                const pathParts = firstEntry.fullPath.split('/'); rootPath = pathParts.length > 1 ? '/' + pathParts[1] : '/'; console.log('Root path determined as:', rootPath);
                const rootGitignoreEntry = entries.find(e => e && e.isFile && e.name === '.gitignore' && e.fullPath === `${rootPath === '/' ? '' : rootPath}/.gitignore`);
                if (rootGitignoreEntry) {
                    console.log('Found .gitignore at root level.');
                    await new Promise((resolve, reject) => rootGitignoreEntry.file(async file => { await parseGitignore(file); resolve(); }, reject)).catch(err => console.error("Error reading root .gitignore:", err));
                } else console.log('No .gitignore found at the determined root level.');
            }
            for (const entry of entries) {
                if (!entry) continue;
                if (entry.isDirectory) processingPromises.push(readDirectoryEntriesRecursive(entry, collectedFiles));
                else if (entry.isFile) {
                    const filePath = entry.fullPath;
                    if (entry.name !== '.gitignore' && !isPathIgnored(filePath)) {
                        processingPromises.push(new Promise((resolve, reject) => entry.file(file => { file.relativePath = filePath; if (isTextFile(file)) collectedFiles.push(file); resolve(); }, err => { console.error(`Error getting file object for ${filePath}:`, err); reject(err); })));
                    }
                }
            }
            try { await Promise.all(processingPromises); addFiles(collectedFiles); }
            catch (error) { console.error("Error during file/directory processing:", error); alert("ƒê√£ x·∫£y ra l·ªói khi x·ª≠ l√Ω files ho·∫∑c th∆∞ m·ª•c. Vui l√≤ng ki·ªÉm tra console."); addFiles(collectedFiles); }
            finally { hideLoading(); }
        };

        // --- File/Directory Handling (showDirectoryPicker API) ---
        const getFilesFromDirectoryHandleRecursive = async (directoryHandle, currentPath, collectedFilesList) => {
            const currentFullPath = `${currentPath}/${directoryHandle.name}`;
            if (isPathIgnored(currentFullPath + '/')) return;
            try { const gitignoreHandle = await directoryHandle.getFileHandle('.gitignore', { create: false }); const gitignoreFile = await gitignoreHandle.getFile(); if (await parseGitignore(gitignoreFile)) console.log(`Parsed .gitignore in: ${currentFullPath}`); } catch (e) { /* No .gitignore */ }
            try {
                for await (const entry of directoryHandle.values()) {
                    const entryPath = `${currentFullPath}/${entry.name}`;
                    if (entry.kind === 'directory') await getFilesFromDirectoryHandleRecursive(entry, currentFullPath, collectedFilesList);
                    else if (entry.kind === 'file') {
                        if (entry.name !== '.gitignore' && !isPathIgnored(entryPath)) {
                            try { const file = await entry.getFile(); file.relativePath = entryPath; if (isTextFile(file)) collectedFilesList.push(file); }
                            catch (fileError) { console.error(`Error getting file object for ${entryPath} (picker):`, fileError); }
                        }
                    }
                }
            } catch (dirError) { console.error(`Error iterating directory handle ${currentFullPath} (picker):`, dirError); }
        };

        const requestDirectoryAccess = async () => {
            if (!('showDirectoryPicker' in window)) { alert('Tr√¨nh duy·ªát c·ªßa b·∫°n kh√¥ng h·ªó tr·ª£ ch·ªçn th∆∞ m·ª•c. Vui l√≤ng k√©o th·∫£ th∆∞ m·ª•c v√†o ho·∫∑c d√πng tr√¨nh duy·ªát Chrome/Edge m·ªõi nh·∫•t.'); return; }
            try {
                showLoading('ƒêang ch·ªù ch·ªçn th∆∞ m·ª•c...'); const directoryHandle = await window.showDirectoryPicker(); showLoading('ƒêang qu√©t th∆∞ m·ª•c...');
                gitignoreRules = []; gitignoreFound = false; rootPath = '/' + directoryHandle.name;
                let collectedFiles = [];
                try { const gitignoreHandle = await directoryHandle.getFileHandle('.gitignore', { create: false }); const gitignoreFile = await gitignoreHandle.getFile(); await parseGitignore(gitignoreFile); } catch (e) { console.log('Kh√¥ng t√¨m th·∫•y .gitignore ·ªü th∆∞ m·ª•c g·ªëc ƒë√£ ch·ªçn (picker).'); }
                await getFilesFromDirectoryHandleRecursive(directoryHandle, '', collectedFiles);
                showLoading(`ƒê√£ qu√©t xong. ƒêang x·ª≠ l√Ω ${collectedFiles.length} file text...`); addFiles(collectedFiles);
            } catch (err) {
                if (err.name !== 'AbortError') { console.error('L·ªói khi truy c·∫≠p th∆∞ m·ª•c (picker):', err); alert(`L·ªói khi truy c·∫≠p th∆∞ m·ª•c: ${err.message}`); }
                else console.log('Ng∆∞·ªùi d√πng ƒë√£ h·ªßy ch·ªçn th∆∞ m·ª•c.');
            } finally { hideLoading(); }
        };

        // --- Core File Handling Logic ---
        const addFiles = (newFiles) => {
            if (!Array.isArray(newFiles) || newFiles.length === 0) { console.log("addFiles: No valid new files provided."); updateStats(); hideLoading(); return; }
            const uniqueNewFiles = []; const existingPaths = new Set(files.map(f => f.relativePath || f.name));
            for (const file of newFiles) {
                if (!file || !(file instanceof File) || !(file.relativePath || file.name)) { console.warn("Skipping invalid file object:", file); continue; }
                const pathKey = file.relativePath || file.name;
                if (!existingPaths.has(pathKey)) { uniqueNewFiles.push(file); existingPaths.add(pathKey); }
            }
            if (uniqueNewFiles.length > 0) {
                files = [...files, ...uniqueNewFiles];
                files.sort((a, b) => (a.relativePath || a.name).localeCompare(b.relativePath || b.name, undefined, { numeric: true, sensitivity: 'base' }));
                displayFileList(); readFilesContent();
            } else { console.log("No new unique files to add."); updateStats(); hideLoading(); }
        };

        const removeFile = (index) => {
            if (index >= 0 && index < files.length) { const removedFile = files.splice(index, 1)[0]; console.log(`Removed file: ${removedFile.relativePath || removedFile.name}`); displayFileList(); readFilesContent(); }
        };

        const readFilesContent = async () => {
            textContent.value = ''; if (files.length === 0) { updateStats(); hideLoading(); return; }
            showLoading(`ƒêang ƒë·ªçc ${files.length} file...`); let combinedContent = ''; let readCount = 0; const totalFiles = files.length; const readPromises = [];
            for (const file of files) {
                readCount++; const displayPath = file.relativePath ? file.relativePath.replace(/^\//, '') : file.name; loadingStatus.textContent = `ƒêang ƒë·ªçc file ${readCount}/${totalFiles}: ${displayPath}`;
                readPromises.push(readFileAsync(file).then(content => { combinedContent += `/* ===== ${displayPath} ===== */\n${content}\n\n`; }).catch(error => { console.error(`L·ªói khi ƒë·ªçc file ${displayPath}:`, error); combinedContent += `/* ===== ERROR: Kh√¥ng th·ªÉ ƒë·ªçc file: ${displayPath} ===== */\n/* ${error.message} */\n\n`; }));
            }
            try { await Promise.all(readPromises); textContent.value = combinedContent; }
            catch (error) { console.error("Error during parallel file reading:", error); alert("ƒê√£ x·∫£y ra l·ªói khi ƒë·ªçc m·ªôt s·ªë file. N·ªôi dung c√≥ th·ªÉ kh√¥ng ƒë·∫ßy ƒë·ªß."); textContent.value = combinedContent; }
            finally { updateStats(); hideLoading(); }
        };

        // --- UI Updates ---
        const updateStats = () => {
            const totalSize = files.reduce((sum, file) => sum + (file?.size || 0), 0); const charCount = textContent.value.length; const gitignoreStatus = gitignoreFound ? ` | .gitignore: C√≥ (${gitignoreRules.length} quy t·∫Øc)` : '';
            stats.textContent = `Files: ${files.length} | T·ªïng k√≠ch th∆∞·ªõc: ${formatFileSize(totalSize)} | Context: ${charCount.toLocaleString()} k√Ω t·ª±${gitignoreStatus}`;
        };

        const displayFileList = () => {
            fileList.innerHTML = '';
            if (files.length === 0) { fileList.innerHTML = '<p class="text-gray-500 text-sm italic">Ch∆∞a c√≥ file n√†o ƒë∆∞·ª£c ch·ªçn.</p>'; dropAreaContent.classList.remove('hidden'); }
            else {
                dropAreaContent.classList.add('hidden');
                files.forEach((file, index) => {
                    const fileItem = document.createElement('div'); fileItem.className = 'file-item flex justify-between items-center bg-gray-100 p-2 rounded mb-2 text-sm';
                    const fileInfo = document.createElement('div'); fileInfo.className = 'file-info overflow-hidden mr-2';
                    const displayName = file.relativePath ? file.relativePath.replace(/^\//, '') : file.name;
                    fileInfo.innerHTML = `<div class="file-name font-medium text-gray-800 whitespace-nowrap overflow-hidden text-ellipsis" title="${displayName}">${displayName}</div><div class="file-size text-xs text-gray-500">${formatFileSize(file.size || 0)}</div>`;
                    const removeButton = document.createElement('button'); removeButton.innerHTML = '‚úï'; removeButton.className = 'remove-btn flex-shrink-0 bg-red-500 hover:bg-red-600 text-white text-xs font-bold w-5 h-5 rounded-full flex items-center justify-center transition duration-200'; removeButton.title = `X√≥a file ${displayName}`;
                    removeButton.onclick = (e) => { e.stopPropagation(); removeFile(index); };
                    fileItem.appendChild(fileInfo); fileItem.appendChild(removeButton); fileList.appendChild(fileItem);
                });
            }
            updateStats();
        };

        const showLoading = (statusText = 'ƒêang x·ª≠ l√Ω...') => { loadingStatus.textContent = statusText; loading.classList.remove('hidden'); loading.classList.add('flex'); };
        const hideLoading = () => { loading.classList.add('hidden'); loading.classList.remove('flex'); loadingStatus.textContent = ''; };

        // --- Clipboard and Copy ---
        const showCopySuccess = (success = true) => {
            if (success) { copySuccess.classList.add('opacity-100'); copySuccess.classList.remove('opacity-0'); setTimeout(() => { copySuccess.classList.remove('opacity-100'); copySuccess.classList.add('opacity-0'); }, 2000); }
            else { alert("Kh√¥ng th·ªÉ sao ch√©p n·ªôi dung v√†o clipboard. Tr√¨nh duy·ªát c·ªßa b·∫°n c√≥ th·ªÉ kh√¥ng h·ªó tr·ª£ ho·∫∑c c·∫ßn c·∫•p quy·ªÅn."); }
        };

        const fallbackCopy = (textToCopy) => {
            const textArea = document.createElement('textarea'); textArea.value = textToCopy; textArea.style.position = 'fixed'; textArea.style.top = '-9999px'; textArea.style.left = '-9999px'; textArea.style.opacity = '0'; document.body.appendChild(textArea); textArea.focus(); textArea.select(); let successful = false;
            try { successful = document.execCommand('copy'); } catch (err) { console.error('L·ªói fallback copy:', err); successful = false; } document.body.removeChild(textArea); showCopySuccess(successful);
        };

        const copyContentToClipboard = async () => {
            const content = textContent.value; if (!content) { alert("Kh√¥ng c√≥ n·ªôi dung ƒë·ªÉ sao ch√©p."); return; }
            if (navigator.clipboard && window.isSecureContext) { try { await navigator.clipboard.writeText(content); showCopySuccess(true); } catch (err) { console.error('L·ªói khi sao ch√©p b·∫±ng Clipboard API:', err); fallbackCopy(content); } }
            else { console.warn('Clipboard API kh√¥ng kh·∫£ d·ª•ng, s·ª≠ d·ª•ng fallback.'); fallbackCopy(content); }
        };

        const handlePaste = async (e) => {
            if (e.target === textContent) { setTimeout(updateStats, 50); return; }
            e.preventDefault(); console.log("Paste event detected on document."); const clipboardData = e.clipboardData; if (!clipboardData) { console.log("Kh√¥ng c√≥ d·ªØ li·ªáu clipboard."); return; }
            if (clipboardData.items && clipboardData.items.length > 0) {
                console.log(`ƒêang x·ª≠ l√Ω ${clipboardData.items.length} item t·ª´ clipboard...`); showLoading('ƒêang x·ª≠ l√Ω n·ªôi dung t·ª´ clipboard...');
                const hasEntries = Array.from(clipboardData.items).some(item => item.kind === 'file' && typeof item.webkitGetAsEntry === 'function');
                if (hasEntries) await handleDropWithItems(clipboardData.items);
                else if (clipboardData.files && clipboardData.files.length > 0) { const pastedFiles = Array.from(clipboardData.files).filter(file => { file.relativePath = '/' + file.name; return isTextFile(file); }); if (pastedFiles.length > 0) addFiles(pastedFiles); else hideLoading(); }
                else if (clipboardData.types.includes('text/plain')) { const pastedText = clipboardData.getData('text/plain'); if (pastedText) { const blob = new Blob([pastedText], { type: 'text/plain' }); const pastedFile = new File([blob], `pasted_text_${Date.now()}.txt`, { type: 'text/plain' }); pastedFile.relativePath = '/' + pastedFile.name; addFiles([pastedFile]); } else { hideLoading(); } }
                else { console.log("Clipboard kh√¥ng ch·ª©a files, entries, ho·∫∑c text h·ª£p l·ªá."); hideLoading(); } return;
            }
            if (clipboardData.types.includes('text/plain')) { console.log("ƒêang x·ª≠ l√Ω text t·ª´ clipboard (fallback)..."); const pastedText = clipboardData.getData('text/plain'); if (pastedText) { const blob = new Blob([pastedText], { type: 'text/plain' }); const pastedFile = new File([blob], `pasted_text_${Date.now()}.txt`, { type: 'text/plain' }); pastedFile.relativePath = '/' + pastedFile.name; addFiles([pastedFile]); } else { hideLoading(); } return; }
            console.log("Kh√¥ng t√¨m th·∫•y n·ªôi dung file ho·∫∑c text h·ª£p l·ªá trong clipboard."); hideLoading();
        };

        // --- Event Listeners ---
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => dropArea.addEventListener(eventName, preventDefaults, false));
        ['dragover', 'drop'].forEach(eventName => document.body.addEventListener(eventName, preventDefaults, false));
        ['dragenter', 'dragover'].forEach(eventName => dropArea.addEventListener(eventName, highlight, false));
        ['dragleave', 'drop'].forEach(eventName => dropArea.addEventListener(eventName, unhighlight, false));
        dropArea.addEventListener('drop', async (e) => {
            unhighlight(); const dt = e.dataTransfer; if (!dt) return;
            if (dt.items && dt.items.length > 0 && typeof dt.items[0].webkitGetAsEntry === 'function') await handleDropWithItems(dt.items);
            else if (dt.files && dt.files.length > 0) { showLoading(`ƒêang x·ª≠ l√Ω ${dt.files.length} file...`); const droppedFiles = Array.from(dt.files).filter(file => { file.relativePath = '/' + file.name; return isTextFile(file); }); if (droppedFiles.length > 0) addFiles(droppedFiles); else hideLoading(); }
            else { console.log("Kh√¥ng t√¨m th·∫•y files ho·∫∑c items h·ª£p l·ªá trong s·ª± ki·ªán drop."); hideLoading(); }
        }, false);
        fileInput.addEventListener('change', (e) => {
            if (e.target.files && e.target.files.length > 0) { showLoading(`ƒêang x·ª≠ l√Ω ${e.target.files.length} file ƒë√£ ch·ªçn...`); const selectedFiles = Array.from(e.target.files).filter(file => { file.relativePath = file.webkitRelativePath ? '/' + file.webkitRelativePath : '/' + file.name; return isTextFile(file); }); if (selectedFiles.length > 0) addFiles(selectedFiles); else hideLoading(); }
            e.target.value = null;
        });
        clearBtn.addEventListener('click', () => { files = []; gitignoreRules = []; gitignoreFound = false; rootPath = ''; textContent.value = ''; displayFileList(); console.log("ƒê√£ x√≥a t·∫•t c·∫£ files v√† n·ªôi dung."); });
        copyBtn.addEventListener('click', copyContentToClipboard);
        document.addEventListener('paste', handlePaste);

        // --- Initial Setup ---
        displayFileList();
        hideLoading();

    </script>
</body>

</html>