<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>·ª®ng d·ª•ng G·ªôp File</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: Arial, sans-serif;
        }

        body {
            background-color: #f5f5f5;
            padding: 20px;
        }

        .container {
            display: flex;
            gap: 20px;
            max-width: 1200px;
            margin: 0 auto;
            height: 90vh;
        }

        .panel {
            flex: 1;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            background-color: white;
        }

        .panel-header {
            padding: 15px;
            background-color: #4a6fa5;
            color: white;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .drop-area {
            flex: 1;
            border: 3px dashed #ccc;
            padding: 20px;
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 1.2rem;
            color: #555;
            background-color: #fafafa;
            transition: all 0.3s;
            margin: 15px;
            border-radius: 8px;
            overflow-y: auto;
        }

        .drop-area.active {
            border-color: #4a6fa5;
            background-color: rgba(74, 111, 165, 0.1);
        }

        .file-list {
            margin-top: 20px;
            width: 100%;
            max-height: 300px;
            overflow-y: auto;
        }

        .file-item {
            padding: 8px;
            background-color: #e9e9e9;
            margin-bottom: 8px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .file-name {
            font-size: 14px;
            font-weight: bold;
            color: #333;
            word-break: break-all;
            padding-right: 10px;
        }

        .file-size {
            font-size: 12px;
            color: #666;
        }

        .content-area {
            flex: 1;
            padding: 15px;
            display: flex;
            flex-direction: column;
        }

        .text-content {
            flex: 1;
            padding: 15px;
            resize: none;
            border: 1px solid #ccc;
            border-radius: 8px;
            font-size: 14px;
            line-height: 1.5;
            outline: none;
            font-family: 'Courier New', monospace;
        }

        .button-area {
            display: flex;
            justify-content: flex-end;
            margin-top: 15px;
            gap: 10px;
        }

        .copy-btn,
        .action-btn,
        .clear-btn {
            padding: 10px 20px;
            background-color: #4a6fa5;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s;
        }

        .copy-btn:hover,
        .action-btn:hover,
        .clear-btn:hover {
            background-color: #3a5780;
        }

        .copy-btn:active,
        .action-btn:active,
        .clear-btn:active {
            transform: translateY(1px);
        }

        .clear-btn {
            background-color: #d9534f;
        }

        .clear-btn:hover {
            background-color: #c9302c;
        }

        .copy-success {
            margin-right: 15px;
            color: #4CAF50;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .copy-success.show {
            opacity: 1;
        }

        .icon {
            margin-right: 10px;
            font-size: 2rem;
            color: #4a6fa5;
        }

        .stats {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
            text-align: right;
        }

        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            display: none;
        }

        .spinner {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #4a6fa5;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
                height: auto;
            }

            .panel {
                margin-bottom: 20px;
                height: 50vh;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <!-- Panel b√™n tr√°i ƒë·ªÉ k√©o th·∫£ file -->
        <div class="panel">
            <div class="panel-header">
                <span>K√©o th·∫£ files ho·∫∑c folders</span>
                <button id="clearBtn" class="clear-btn" style="padding: 5px 10px;">X√≥a t·∫•t c·∫£</button>
            </div>
            <div id="dropArea" class="drop-area">
                <div class="icon">üìÅ</div>
                <p>K√©o th·∫£ files ho·∫∑c folders v√†o ƒë√¢y</p>
                <p>ho·∫∑c</p>
                <input type="file" id="fileInput" multiple webkitdirectory directory style="display: none;">
                <div style="display: flex; gap: 10px; margin-top: 10px;">
                    <button onclick="document.getElementById('fileInput').click()" class="copy-btn">Ch·ªçn Files</button>
                    <button onclick="requestDirectoryAccess()" class="copy-btn">Ch·ªçn Folder</button>
                </div>
                <div id="fileList" class="file-list"></div>
            </div>
        </div>

        <!-- Panel b√™n ph·∫£i ƒë·ªÉ hi·ªÉn th·ªã n·ªôi dung -->
        <div class="panel">
            <div class="panel-header">N·ªôi dung g·ªôp</div>
            <div class="content-area">
                <textarea id="textContent" class="text-content" readonly
                    placeholder="N·ªôi dung c·ªßa c√°c file s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y..."></textarea>
                <div id="stats" class="stats">Files: 0 | T·ªïng k√≠ch th∆∞·ªõc: 0 KB | Context: 0 k√Ω t·ª±</div>
                <div class="button-area">
                    <span id="copySuccess" class="copy-success">ƒê√£ sao ch√©p!</span>
                    <button id="copyBtn" class="copy-btn">Sao ch√©p n·ªôi dung</button>
                </div>
            </div>
        </div>
    </div>

    <div id="loading" class="loading">
        <div class="spinner"></div>
        <p>ƒêang x·ª≠ l√Ω files...</p>
        <p id="loadingStatus"></p>
    </div>

    <script>
        // L·∫•y c√°c ph·∫ßn t·ª≠ DOM
        const dropArea = document.getElementById('dropArea');
        const fileInput = document.getElementById('fileInput');
        const fileList = document.getElementById('fileList');
        const textContent = document.getElementById('textContent');
        const copyBtn = document.getElementById('copyBtn');
        const copySuccess = document.getElementById('copySuccess');
        const clearBtn = document.getElementById('clearBtn');
        const stats = document.getElementById('stats');
        const loading = document.getElementById('loading');
        const loadingStatus = document.getElementById('loadingStatus');

        // M·∫£ng l∆∞u tr·ªØ t·∫•t c·∫£ c√°c file ƒë√£ ch·ªçn
        let files = [];

        // Danh s√°ch m·ªü r·ªông file text ph·ªï bi·∫øn
        const textFileExtensions = [
            // Web
            'html', 'htm', 'css', 'js', 'jsx', 'ts', 'tsx', 'json', 'xml', 'svg', 'xhtml',
            // PHP
            'php', 'phtml', 'php3', 'php4', 'php5', 'phps', 'inc',
            // Python
            'py', 'pyw', 'pyc', 'pyd', 'pyo', 'pyx', 'ipynb',
            // Ruby
            'rb', 'rbw', 'rake', 'gemspec', 'erb',
            // Java
            'java', 'class', 'jsp', 'jspx', 'properties',
            // C/C++
            'c', 'cpp', 'cc', 'h', 'hpp', 'hxx', 'cxx',
            // C#
            'cs', 'csx', 'razor',
            // Go
            'go', 'mod',
            // Rust
            'rs', 'rlib',
            // Scala
            'scala', 'sc',
            // Swift
            'swift',
            // JavaScript/TypeScript
            'js', 'jsx', 'ts', 'tsx', 'mjs', 'cjs',
            // Shell scripts
            'sh', 'bash', 'zsh', 'fish', 'cmd', 'bat', 'ps1',
            // SQL
            'sql', 'sqlite', 'psql',
            // Document formats
            'txt', 'md', 'markdown', 'rst', 'tex', 'log', 'rtf', 'wiki', 'csv', 'tsv',
            // Config files
            'yaml', 'yml', 'toml', 'ini', 'conf', 'cfg', 'env', 'htaccess',
            // Other code files
            'dart', 'lua', 'r', 'pl', 'pm', 'kt', 'kts', 'groovy', 'gradle',
            // Data files
            'csv', 'tsv', 'json', 'xml', 'yaml', 'yml', 'graphql', 'gql',
            // Documentation
            'md', 'txt', 'rst', 'adoc', 'wiki', 'textile',
            // VCS
            'gitignore', 'gitattributes', 'gitmodules',
            // Build systems
            'makefile', 'cmake', 'dockerfile', 'npmrc', 'yarnrc',
            // Functional languages
            'hs', 'lhs', 'elm', 'clj', 'cljs', 'fs', 'fsx', 'ml', 'mli', 'erl', 'hrl',
            // Office documents (text-based)
            'tex', 'bib', 'sty'
        ];

        // Danh s√°ch MIME type c√≥ th·ªÉ ƒë·ªçc ƒë∆∞·ª£c
        const readableMimeTypes = [
            'text/',
            'application/json',
            'application/xml',
            'application/javascript',
            'application/x-javascript',
            'application/ecmascript',
            'application/typescript',
            'application/x-httpd-php',
            'application/x-sh',
            'application/x-csh',
            'application/xhtml+xml',
            'application/x-tex',
            'application/x-latex'
        ];

        // NgƒÉn ch·∫∑n h√†nh vi m·∫∑c ƒë·ªãnh khi k√©o th·∫£
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, preventDefaults, false);
            document.body.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        // Hi·ªáu ·ª©ng khi k√©o file v√†o v√πng th·∫£
        ['dragenter', 'dragover'].forEach(eventName => {
            dropArea.addEventListener(eventName, highlight, false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, unhighlight, false);
        });

        function highlight() {
            dropArea.classList.add('active');
        }

        function unhighlight() {
            dropArea.classList.remove('active');
        }

        // X·ª≠ l√Ω s·ª± ki·ªán khi th·∫£ file ho·∫∑c folder
        dropArea.addEventListener('drop', async function (e) {
            const dt = e.dataTransfer;

            // Ki·ªÉm tra n·∫øu c√≥ th∆∞ m·ª•c
            if (dt.items) {
                await handleDropWithItems(dt.items);
            } else {
                // Fallback cho tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ DataTransferItemList
                handleFiles([...dt.files]);
            }
        });

        // X·ª≠ l√Ω khi k√©o th·∫£ c√≥ items (c√≥ th·ªÉ l√† file ho·∫∑c folder)
        async function handleDropWithItems(items) {
            loading.style.display = 'flex';
            loadingStatus.textContent = 'ƒêang qu√©t files...';

            let newFiles = [];
            let promises = [];

            for (let i = 0; i < items.length; i++) {
                const item = items[i];

                // Ki·ªÉm tra xem item c√≥ ph·∫£i l√† file hay folder
                if (item.kind === 'file') {
                    const entry = item.webkitGetAsEntry ? item.webkitGetAsEntry() : null;

                    if (entry) {
                        if (entry.isFile) {
                            // N·∫øu l√† file, th√™m v√†o danh s√°ch
                            promises.push(new Promise(resolve => {
                                entry.file(file => {
                                    newFiles.push(file);
                                    resolve();
                                });
                            }));
                        } else if (entry.isDirectory) {
                            // N·∫øu l√† th∆∞ m·ª•c, ƒë·ªçc to√†n b·ªô file trong th∆∞ m·ª•c ƒë√≥
                            promises.push(readDirectoryEntries(entry, newFiles));
                        }
                    } else {
                        // Fallback n·∫øu webkitGetAsEntry kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£
                        const file = item.getAsFile();
                        if (file) newFiles.push(file);
                    }
                }
            }

            // ƒê·ª£i t·∫•t c·∫£ c√°c promises ho√†n t·∫•t
            await Promise.all(promises);

            // L·ªçc c√°c file text
            const textFiles = newFiles.filter(file => isTextFile(file));

            handleFiles(textFiles);
            loading.style.display = 'none';
        }

        // ƒê·ªçc ƒë·ªá quy to√†n b·ªô file t·ª´ m·ªôt th∆∞ m·ª•c
        async function readDirectoryEntries(directoryEntry, fileList) {
            const reader = directoryEntry.createReader();

            // H√†m ƒë·ªçc c√°c entries trong th∆∞ m·ª•c
            async function readEntries() {
                return new Promise((resolve, reject) => {
                    reader.readEntries(entries => resolve(entries), error => reject(error));
                });
            }

            let entries;
            const promises = [];

            do {
                entries = await readEntries();

                for (let i = 0; i < entries.length; i++) {
                    const entry = entries[i];

                    if (entry.isFile) {
                        // N·∫øu l√† file, th√™m v√†o danh s√°ch
                        promises.push(new Promise(resolve => {
                            entry.file(file => {
                                // Th√™m ƒë∆∞·ªùng d·∫´n t∆∞∆°ng ƒë·ªëi v√†o file object ƒë·ªÉ hi·ªÉn th·ªã
                                file.relativePath = directoryEntry.fullPath + '/' + file.name;
                                fileList.push(file);
                                resolve();
                            });
                        }));
                    } else if (entry.isDirectory) {
                        // N·∫øu l√† th∆∞ m·ª•c, ƒë·ªçc ƒë·ªá quy
                        promises.push(readDirectoryEntries(entry, fileList));
                    }
                }
            } while (entries.length > 0);

            // ƒê·ª£i t·∫•t c·∫£ c√°c promises
            await Promise.all(promises);
        }

        // X·ª≠ l√Ω s·ª± ki·ªán khi ch·ªçn files t·ª´ input
        fileInput.addEventListener('change', function () {
            const newFiles = [...this.files];
            handleFiles(newFiles);
        });

        // H·ªó tr·ª£ ch·ªçn th∆∞ m·ª•c
        async function requestDirectoryAccess() {
            try {
                // S·ª≠ d·ª•ng File System Access API n·∫øu ƒë∆∞·ª£c h·ªó tr·ª£
                if ('showDirectoryPicker' in window) {
                    loading.style.display = 'flex';
                    loadingStatus.textContent = 'ƒêang ch·ªçn th∆∞ m·ª•c...';

                    const directoryHandle = await window.showDirectoryPicker();
                    const fileHandles = [];

                    // H√†m ƒë·ªá quy ƒë·ªÉ ƒë·ªçc t·∫•t c·∫£ c√°c file trong th∆∞ m·ª•c
                    async function getFilesRecursively(directoryHandle, path = '') {
                        for await (const entry of directoryHandle.values()) {
                            const entryPath = path + '/' + entry.name;

                            if (entry.kind === 'file') {
                                fileHandles.push({ handle: entry, path: entryPath });
                            } else if (entry.kind === 'directory') {
                                await getFilesRecursively(entry, entryPath);
                            }
                        }
                    }

                    await getFilesRecursively(directoryHandle);

                    // Chuy·ªÉn ƒë·ªïi c√°c file handles th√†nh File objects
                    loading.style.display = 'flex';
                    loadingStatus.textContent = 'ƒêang ƒë·ªçc files...';

                    const newFiles = [];

                    for (let i = 0; i < fileHandles.length; i++) {
                        const fileHandle = fileHandles[i];
                        const file = await fileHandle.handle.getFile();
                        // Th√™m ƒë∆∞·ªùng d·∫´n t∆∞∆°ng ƒë·ªëi v√†o file
                        file.relativePath = fileHandle.path;

                        if (isTextFile(file)) {
                            newFiles.push(file);
                        }

                        // C·∫≠p nh·∫≠t tr·∫°ng th√°i
                        loadingStatus.textContent = `ƒêang ƒë·ªçc files... (${i + 1}/${fileHandles.length})`;
                    }

                    handleFiles(newFiles);
                } else {
                    // Fallback cho tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ File System Access API
                    alert('Tr√¨nh duy·ªát c·ªßa b·∫°n kh√¥ng h·ªó tr·ª£ ch·ªçn th∆∞ m·ª•c. Vui l√≤ng k√©o th·∫£ th∆∞ m·ª•c v√†o ho·∫∑c d√πng tr√¨nh duy·ªát Chrome/Edge m·ªõi nh·∫•t.');
                }
            } catch (err) {
                console.error('Error accessing directory:', err);
            } finally {
                loading.style.display = 'none';
            }
        }

        // X√≥a t·∫•t c·∫£ file
        clearBtn.addEventListener('click', function () {
            files = [];
            displayFileList();
            textContent.value = '';
            updateStats();
        });

        // X·ª≠ l√Ω c√°c file ƒë∆∞·ª£c ch·ªçn
        function handleFiles(newFiles) {
            // Th√™m files m·ªõi v√†o m·∫£ng
            files = [...files, ...newFiles];

            // Hi·ªÉn th·ªã danh s√°ch file v√† ƒë·ªçc n·ªôi dung
            displayFileList();
            readFilesContent();
        }

        // Hi·ªÉn th·ªã danh s√°ch file
        function displayFileList() {
            fileList.innerHTML = '';

            files.forEach((file, index) => {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';

                const fileInfo = document.createElement('div');
                // Hi·ªÉn th·ªã t√™n file v·ªõi ƒë∆∞·ªùng d·∫´n t∆∞∆°ng ƒë·ªëi n·∫øu c√≥
                const displayName = file.relativePath ? file.relativePath.substring(1) : file.name;

                fileInfo.innerHTML = `
          <div class="file-name" title="${displayName}">${displayName}</div>
          <div class="file-size">${formatFileSize(file.size)}</div>
        `;

                const removeButton = document.createElement('button');
                removeButton.innerHTML = '‚úï';
                removeButton.className = 'copy-btn';
                removeButton.style.padding = '3px 8px';
                removeButton.onclick = (e) => {
                    e.stopPropagation();
                    removeFile(index);
                };

                fileItem.appendChild(fileInfo);
                fileItem.appendChild(removeButton);
                fileList.appendChild(fileItem);
            });

            updateStats();
        }

        // C·∫≠p nh·∫≠t th·ªëng k√™
        function updateStats() {
            const totalSize = files.reduce((sum, file) => sum + file.size, 0);
            const charCount = textContent.value.length;
            stats.textContent = `Files: ${files.length} | T·ªïng k√≠ch th∆∞·ªõc: ${formatFileSize(totalSize)} | Context: ${charCount.toLocaleString()} k√Ω t·ª±`;
        }

        // ƒê·ªãnh d·∫°ng k√≠ch th∆∞·ªõc file
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';

            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));

            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // X√≥a file
        function removeFile(index) {
            files.splice(index, 1);
            displayFileList();
            readFilesContent();
        }

        // Ki·ªÉm tra xem file c√≥ ph·∫£i l√† file text/code kh√¥ng
        function isTextFile(file) {
            // Ki·ªÉm tra mime type
            if (file.type) {
                for (const mimeType of readableMimeTypes) {
                    if (file.type.startsWith(mimeType)) {
                        return true;
                    }
                }
            }

            // Ki·ªÉm tra ph·∫ßn m·ªü r·ªông file
            const extension = file.name.split('.').pop().toLowerCase();
            if (textFileExtensions.includes(extension)) {
                return true;
            }

            // Ki·ªÉm tra t√™n file kh√¥ng c√≥ ph·∫ßn m·ªü r·ªông nh∆∞ng l√† text file ph·ªï bi·∫øn
            const filenameWithoutExt = file.name.toLowerCase();
            const commonTextFiles = ['dockerfile', 'makefile', 'readme', 'license', 'authors', 'changelog',
                'gitignore', 'bashrc', 'zshrc', '.env', '.gitignore', '.npmrc'];

            if (commonTextFiles.includes(filenameWithoutExt)) {
                return true;
            }

            // N·∫øu file nh·ªè (d∆∞·ªõi 100KB), h√£y coi l√† text file
            if (file.size < 100 * 1024) {
                return true;
            }

            return false;
        }

        // ƒê·ªçc n·ªôi dung c·ªßa t·∫•t c·∫£ c√°c file
        async function readFilesContent() {
            textContent.value = '';

            if (files.length === 0) {
                updateStats(); // C·∫≠p nh·∫≠t th·ªëng k√™ khi kh√¥ng c√≥ file
                return;
            }

            loading.style.display = 'flex';

            try {
                const contents = [];

                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    loadingStatus.textContent = `ƒêang ƒë·ªçc file ${i + 1}/${files.length}: ${file.name}`;

                    try {
                        // ƒê·ªçc n·ªôi dung file
                        const content = await readFileAsync(file);

                        // Hi·ªÉn th·ªã ƒë∆∞·ªùng d·∫´n t∆∞∆°ng ƒë·ªëi n·∫øu c√≥
                        const displayPath = file.relativePath ? file.relativePath.substring(1) : file.name;
                        contents.push(`/* ===== ${displayPath} ===== */\n${content}\n\n`);
                    } catch (error) {
                        console.error('Error reading file:', file.name, error);
                        contents.push(`/* Kh√¥ng th·ªÉ ƒë·ªçc file: ${file.name} - ${error.message} */\n\n`);
                    }
                }

                // G·ªôp n·ªôi dung t·∫•t c·∫£ c√°c file
                textContent.value = contents.join('');
                updateStats(); // C·∫≠p nh·∫≠t th·ªëng k√™ sau khi ƒë·ªçc files
            } finally {
                loading.style.display = 'none';
            }
        }

        // H√†m ƒë·ªçc file v·ªõi Promise
        function readFileAsync(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();

                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = (e) => reject(new Error('L·ªói ƒë·ªçc file'));

                reader.readAsText(file);
            });
        }

        // X·ª≠ l√Ω s·ª± ki·ªán sao ch√©p n·ªôi dung
        copyBtn.addEventListener('click', function () {
            if (navigator.clipboard && window.isSecureContext) {
                // S·ª≠ d·ª•ng Clipboard API n·∫øu ƒë∆∞·ª£c h·ªó tr·ª£ (HTTPS)
                navigator.clipboard.writeText(textContent.value)
                    .then(() => {
                        copySuccess.classList.add('show');
                        setTimeout(() => {
                            copySuccess.classList.remove('show');
                        }, 2000);
                    })
                    .catch(err => {
                        console.error('Kh√¥ng th·ªÉ sao ch√©p:', err);
                        fallbackCopyText();
                    });
            } else {
                // Fallback cho c√°c tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£
                fallbackCopyText();
            }
        });

        function fallbackCopyText() {
            textContent.select();
            document.execCommand('copy');

            copySuccess.classList.add('show');
            setTimeout(() => {
                copySuccess.classList.remove('show');
            }, 2000);

            // H·ªßy ch·ªçn vƒÉn b·∫£n
            window.getSelection().removeAllRanges();
        }

        // Th√™m s·ª± ki·ªán l·∫Øng nghe thay ƒë·ªïi n·ªôi dung ƒë·ªÉ c·∫≠p nh·∫≠t s·ªë k√Ω t·ª±
        textContent.addEventListener('input', updateStats);
    </script>
</body>

</html>