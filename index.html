<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>·ª®ng d·ª•ng G·ªôp File (Tailwind - Hi·ªÉn th·ªã file b·ªè qua)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // Optional: Customize Tailwind theme if needed
        // tailwind.config = {
        //   theme: {
        //     extend: {
        //       colors: {
        //         primary: '#4a6fa5', // Example custom color
        //       }
        //     }
        //   }
        // }
    </script>
    <style>
        /* Custom scrollbar styles (optional) */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #a1a1a1;
        }

        /* Add subtle focus ring for accessibility */
        *:focus-visible {
            outline: 2px solid #4a6fa5;
            /* Using a specific blue color */
            outline-offset: 2px;
            border-radius: 4px;
            /* Match button radius */
        }

        /* Style for the loading spinner */
        .spinner {
            border: 5px solid #f3f3f3;
            /* Light grey */
            border-top: 5px solid #4a6fa5;
            /* Blue */
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Ensure drop area border style is consistent */
        #dropArea {
            border-width: 3px;
            /* Explicitly set border width */
        }
    </style>
</head>

<body class="bg-gray-100 font-sans antialiased">
    <div class="container mx-auto p-4 md:p-6 lg:p-8 max-w-7xl">
        <div class="flex flex-col md:flex-row gap-4 md:gap-6 lg:gap-8 h-auto md:h-[90vh]">

            <div
                class="panel flex flex-col bg-white rounded-lg shadow-md overflow-hidden md:w-1/2 lg:w-2/5 min-h-[400px] md:min-h-0">
                <div
                    class="panel-header bg-blue-600 text-white p-4 font-bold flex justify-between items-center flex-shrink-0">
                    <span>K√©o th·∫£ files ho·∫∑c folders</span>
                    <button id="clearBtn"
                        class="clear-btn bg-red-500 hover:bg-red-600 text-white text-xs font-bold py-1 px-3 rounded transition duration-200">X√≥a
                        t·∫•t c·∫£</button>
                </div>
                <div id="dropArea"
                    class="drop-area flex-grow border-dashed border-gray-300 p-4 m-4 rounded-lg text-center flex flex-col justify-center items-center text-gray-600 bg-gray-50 transition duration-300 relative overflow-y-auto min-h-[250px]">
                    <div id="dropAreaContent" class="drop-area-content mb-4 flex flex-col items-center">
                        <div class="text-5xl mb-3 text-blue-500">üìÅ</div>
                        <p class="mb-2">K√©o th·∫£ files ho·∫∑c folders v√†o ƒë√¢y</p>
                        <p class="text-sm text-gray-500 mb-3">ho·∫∑c paste (Ctrl+V) t·ª´ File Explorer</p>
                        <p class="mb-3">ho·∫∑c</p>
                        <input type="file" id="fileInput" multiple webkitdirectory directory style="display: none;">
                        <div class="flex flex-col sm:flex-row gap-3 justify-center">
                            <button
                                onclick="document.getElementById('fileInput').setAttribute('webkitdirectory', false); document.getElementById('fileInput').setAttribute('directory', false); document.getElementById('fileInput').click()"
                                class="action-btn bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded transition duration-200">
                                Ch·ªçn Files
                            </button>
                            <button onclick="requestDirectoryAccess()"
                                class="action-btn bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded transition duration-200">
                                Ch·ªçn Folder
                            </button>
                        </div>
                    </div>
                    <div id="fileList" class="file-list w-full text-left mt-4 max-h-[calc(100%-180px)] overflow-y-auto">
                        <p class="text-gray-500 text-sm italic">Ch∆∞a c√≥ file n√†o ƒë∆∞·ª£c ch·ªçn.</p>
                    </div>
                </div>
            </div>

            <div
                class="panel flex flex-col bg-white rounded-lg shadow-md overflow-hidden md:w-1/2 lg:w-3/5 min-h-[400px] md:min-h-0">
                <div class="panel-header bg-blue-600 text-white p-4 font-bold flex-shrink-0">
                    N·ªôi dung g·ªôp
                </div>
                <div class="content-area flex-grow p-4 flex flex-col overflow-hidden">
                    <textarea id="textContent"
                        class="text-content flex-grow p-3 border border-gray-300 rounded-lg text-sm font-mono resize-none outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent overflow-y-auto mb-3"
                        readonly placeholder="N·ªôi dung c·ªßa c√°c file s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y..."></textarea>
                    <div id="stats" class="stats text-xs text-gray-600 text-right mb-3 flex-shrink-0">Files: 0 | T·ªïng
                        k√≠ch th∆∞·ªõc: 0 Bytes | Context: 0 k√Ω t·ª±</div>
                    <div class="button-area flex flex-col sm:flex-row justify-end items-center gap-3 flex-shrink-0">
                        <span id="copySuccess"
                            class="copy-success text-green-600 font-bold text-sm opacity-0 transition-opacity duration-300 order-1 sm:order-none">ƒê√£
                            sao ch√©p!</span>
                        <button id="copyBtn"
                            class="copy-btn bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded transition duration-200 order-2 sm:order-none w-full sm:w-auto">Sao
                            ch√©p n·ªôi dung</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="loading"
        class="loading fixed inset-0 bg-white bg-opacity-80 flex flex-col justify-center items-center z-50 hidden">
        <div class="spinner mb-4"></div>
        <p class="text-gray-700 font-semibold">ƒêang x·ª≠ l√Ω files...</p>
        <p id="loadingStatus" class="text-gray-600 text-sm mt-1"></p>
    </div>

    <script>
        // ===== JavaScript Code (Refactored) =====

        // --- DOM Elements ---
        const dropArea = document.getElementById('dropArea');
        const fileInput = document.getElementById('fileInput');
        const fileList = document.getElementById('fileList');
        const textContent = document.getElementById('textContent');
        const copyBtn = document.getElementById('copyBtn');
        const copySuccess = document.getElementById('copySuccess');
        const clearBtn = document.getElementById('clearBtn');
        const stats = document.getElementById('stats');
        const loading = document.getElementById('loading');
        const loadingStatus = document.getElementById('loadingStatus');
        const dropAreaContent = document.getElementById('dropAreaContent');

        // --- Constants ---
        const nonTextFileExtensions = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'tiff', 'webp', 'ico', 'heic', 'heif', 'avif', 'icns', 'cur', 'mp3', 'wav', 'aac', 'ogg', 'flac', 'm4a', 'opus', 'mp4', 'mov', 'avi', 'mkv', 'webm', 'flv', 'wmv', 'woff', 'woff2', 'ttf', 'otf', 'eot', 'zip', 'rar', 'tar', 'gz', '7z', 'bz2', 'xz', 'iso', 'img', 'dmg', 'pdf', 'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx', 'odt', 'ods', 'odp', 'key', 'numbers', 'pages', 'exe', 'dll', 'so', 'dylib', 'app', 'msi', 'deb', 'rpm', 'jar', 'db', 'sqlite', 'sqlite3', 'mdb', 'accdb', 'sqlitedb', 'bin', 'dat', 'class', 'pyd', 'pyc', 'pyo', 'o', 'a', 'lib', 'swf', 'psd', 'ai', 'eps', 'lock', 'bak', 'tmp', 'temp', 'swp'];
        const readableMimeTypes = ['text/', 'application/json', 'application/xml', 'application/javascript', 'application/typescript', 'application/x-httpd-php', 'application/x-sh', 'application/xhtml+xml', 'image/svg+xml', 'application/yaml', 'application/toml', 'application/sql', 'application/rtf', 'application/csv', 'application/vnd.mozilla.xul+xml'];
        const commonTextFiles = ['dockerfile', 'makefile', 'readme', 'license', 'authors', 'changelog', 'contributing', 'procfile', 'gemfile', 'rakefile', 'jenkinsfile', 'vagrantfile', 'pipeline', '.env', '.gitattributes', '.gitignore', '.gitmodules', '.npmrc', '.yarnrc', '.npmignore', '.babelrc', '.eslintrc', '.prettierrc', '.editorconfig', '.browserslistrc', 'requirements.txt', 'pipfile', 'go.mod', 'go.sum', 'composer.json', 'package.json', 'tsconfig.json', 'manifest.json', 'config.xml', 'pom.xml', 'build.gradle', 'settings.gradle', 'cmakelists.txt'];
        const defaultIgnoredPatterns = ['.git/', 'node_modules/', 'vendor/', 'bower_components/', 'storage/', 'build/', 'dist/', 'out/', 'target/', '.svn/', '.hg/', '.bzr/', '.idea/', '.vscode/', '.project/', '.settings/', '__pycache__/', '.pytest_cache/', '.mypy_cache/', '.ruff_cache/', 'coverage/', 'logs/', 'tmp/', 'temp/', '*.lockb', '*.log', '*.tmp', '*.bak', '*.swp', '*.DS_Store'];

        // --- State Variables ---
        let files = []; // Array now holds ALL discovered files
        let gitignoreRules = [];
        let gitignoreFound = false;
        let rootPath = '';

        // --- Utility Functions ---
        const preventDefaults = (e) => { e.preventDefault(); e.stopPropagation(); };
        const highlight = () => { dropArea.classList.remove('border-gray-300', 'bg-gray-50'); dropArea.classList.add('border-blue-600', 'bg-blue-600/10'); };
        const unhighlight = () => { dropArea.classList.remove('border-blue-600', 'bg-blue-600/10'); dropArea.classList.add('border-gray-300', 'bg-gray-50'); };
        const formatFileSize = (bytes) => { if (bytes === 0 || isNaN(bytes)) return '0 Bytes'; const k = 1024; const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB']; const i = Math.max(0, Math.min(sizes.length - 1, Math.floor(Math.log(bytes) / Math.log(k)))); return `${parseFloat((bytes / Math.pow(k, i)).toFixed(2))} ${sizes[i]}`; };
        const readFileAsync = (file) => { return new Promise((resolve, reject) => { const reader = new FileReader(); reader.onload = (e) => resolve(e.target.result); reader.onerror = (e) => reject(new Error(`L·ªói ƒë·ªçc file: ${e.target.error?.message || 'Kh√¥ng r√µ'}`)); reader.readAsText(file); }); };

        // --- File Type Checking ---
        const isTextFile = (file) => {
            if (!file || !file.name) return false;
            const fileNameLower = file.name.toLowerCase();
            const extension = fileNameLower.includes('.') ? fileNameLower.split('.').pop() : '';
            if (extension && nonTextFileExtensions.includes(extension)) return false;
            if (file.type) {
                if (readableMimeTypes.some(mime => file.type.startsWith(mime))) return true;
                if (file.type.startsWith('image/') || file.type.startsWith('audio/') || file.type.startsWith('video/') || file.type.startsWith('font/') || file.type.startsWith('application/octet-stream') || file.type.startsWith('application/zip') || file.type.startsWith('application/pdf') || file.type.startsWith('application/msword') || file.type.startsWith('application/vnd.ms-excel') || file.type.startsWith('application/vnd.ms-powerpoint')) return false;
            }
            if (commonTextFiles.includes(fileNameLower)) return true;
            if (fileNameLower.startsWith('.') && commonTextFiles.includes(fileNameLower)) return true;
            if (!extension && !file.type && file.size > 1024) return false; // Avoid large unknown files
            return true; // Assume text if not excluded
        };

        // --- Gitignore and Folder Ignoring Logic ---
        const parseGitignore = async (file) => { try { const content = await readFileAsync(file); gitignoreRules = content.split('\n').map(line => line.trim()).filter(line => line && !line.startsWith('#')).map(rule => rule.replace(/^\\#/, '#')); console.log(`ƒê√£ ƒë·ªçc .gitignore v·ªõi ${gitignoreRules.length} quy t·∫Øc.`); gitignoreFound = true; return true; } catch (error) { console.error('L·ªói khi ƒë·ªçc ho·∫∑c ph√¢n t√≠ch file .gitignore:', error); gitignoreRules = []; gitignoreFound = false; return false; } };
        const matchesIgnorePattern = (path, pattern) => { let isNegation = false; if (pattern.startsWith('!')) { isNegation = true; pattern = pattern.substring(1); } const normalizedPattern = pattern.replace(/^\/+|\/+$/g, ''); const isDirPattern = pattern.endsWith('/'); if (path === normalizedPattern || path === normalizedPattern + '/') return !isNegation; if (isDirPattern && path.startsWith(normalizedPattern + '/')) return !isNegation; if (!pattern.includes('/')) { if (pattern.startsWith('*.')) { const ext = pattern.substring(1); if (path.endsWith(ext)) return !isNegation; } else if (pattern.endsWith('*')) { const prefix = normalizedPattern.slice(0, -1); if (path.split('/').pop().startsWith(prefix)) return !isNegation; } else { if (path.split('/').includes(normalizedPattern)) return !isNegation; } } if (pattern.includes('/') && !isDirPattern && path === normalizedPattern) return !isNegation; return false; };
        const isPathIgnored = (relativePath) => { if (!relativePath) return false; const normalizedPath = relativePath.replace(/^\/+/, ''); let ignored = false; for (const pattern of defaultIgnoredPatterns) { if (matchesIgnorePattern(normalizedPath, pattern)) { ignored = true; break; } } if (gitignoreFound) { let lastMatchWasIgnore = false; let lastMatchWasInclude = false; for (const rule of gitignoreRules) { let currentRule = rule; let isNegationRule = false; if (currentRule.startsWith('!')) { isNegationRule = true; currentRule = currentRule.substring(1); } if (!currentRule) continue; if (matchesIgnorePattern(normalizedPath, rule)) { if (isNegationRule) { lastMatchWasInclude = true; lastMatchWasIgnore = false; } else { lastMatchWasIgnore = true; lastMatchWasInclude = false; } } } if (lastMatchWasInclude) ignored = false; if (lastMatchWasIgnore) ignored = true; } return ignored; };

        // --- File/Directory Handling (Collect ALL files, decide inclusion later) ---
        const readDirectoryEntriesRecursive = async (directoryEntry, currentFilesList) => {
            const currentPath = directoryEntry.fullPath;
            // Only ignore the directory itself if explicitly matched by a pattern ending in '/'
            if (isPathIgnored(currentPath + '/')) {
                console.log('Ignored directory contents:', currentPath);
                return; // Skip reading contents of ignored directory
            }
            const reader = directoryEntry.createReader();
            const readEntriesBatch = () => new Promise((resolve, reject) => reader.readEntries(resolve, reject));
            let entries;
            do {
                try {
                    entries = await readEntriesBatch();
                    if (entries.length > 0) {
                        const entryPromises = [];
                        for (const entry of entries) {
                            const entryPath = entry.fullPath;
                            if (entry.isDirectory) {
                                entryPromises.push(readDirectoryEntriesRecursive(entry, currentFilesList));
                            } else if (entry.isFile) {
                                // Add ALL files, ignoring check will happen later
                                entryPromises.push(new Promise((resolveFile, rejectFile) => {
                                    entry.file(file => {
                                        try {
                                            file.relativePath = entryPath;
                                            // Don't filter here, add all files
                                            currentFilesList.push(file);
                                            resolveFile();
                                        } catch (fileProcessingError) {
                                            console.error(`Error processing file object for ${entryPath}:`, fileProcessingError);
                                            rejectFile(fileProcessingError);
                                        }
                                    }, (err) => {
                                        console.error(`Error getting file object for ${entryPath}:`, err);
                                        rejectFile(err);
                                    });
                                }));
                            }
                        }
                        await Promise.all(entryPromises);
                    }
                } catch (error) { console.error(`Error reading directory entries for ${currentPath}:`, error); break; }
            } while (entries && entries.length > 0);
        };

        const handleDropWithItems = async (items) => {
            showLoading('ƒêang qu√©t files v√† th∆∞ m·ª•c...');
            let collectedFiles = []; let processingPromises = [];
            gitignoreRules = []; gitignoreFound = false; rootPath = '';
            const entries = [];
            for (const item of items) {
                if (item.kind === 'file' && typeof item.webkitGetAsEntry === 'function') entries.push(item.webkitGetAsEntry());
                else if (item.kind === 'file') { const file = item.getAsFile(); if (file) { file.relativePath = '/' + file.name; collectedFiles.push(file); } } // Add all files initially
            }
            if (entries.length === 0 && collectedFiles.length > 0) { addFiles(collectedFiles); hideLoading(); return; }
            if (entries.length === 0) { console.log("Kh√¥ng t√¨m th·∫•y m·ª•c file/folder h·ª£p l·ªá ƒë·ªÉ x·ª≠ l√Ω."); hideLoading(); return; }
            const firstEntry = entries[0];
            if (firstEntry) {
                const pathParts = firstEntry.fullPath.split('/'); rootPath = pathParts.length > 1 ? '/' + pathParts[1] : '/'; console.log('Root path determined as:', rootPath);
                const rootGitignoreEntry = entries.find(e => e && e.isFile && e.name === '.gitignore' && e.fullPath === `${rootPath === '/' ? '' : rootPath}/.gitignore`);
                if (rootGitignoreEntry) { console.log('Found .gitignore at root level.'); await new Promise((resolve, reject) => rootGitignoreEntry.file(async file => { await parseGitignore(file); resolve(); }, reject)).catch(err => console.error("Error reading root .gitignore:", err)); }
                else console.log('No .gitignore found at the determined root level.');
            }
            for (const entry of entries) {
                if (!entry) continue;
                if (entry.isDirectory) processingPromises.push(readDirectoryEntriesRecursive(entry, collectedFiles));
                else if (entry.isFile) {
                    // Add all files found via entries
                    processingPromises.push(new Promise((resolve, reject) => entry.file(file => { file.relativePath = entry.fullPath; collectedFiles.push(file); resolve(); }, err => { console.error(`Error getting file object for ${entry.fullPath}:`, err); reject(err); })));
                }
            }
            try { await Promise.all(processingPromises); addFiles(collectedFiles); }
            catch (error) { console.error("Error during file/directory processing:", error); alert("ƒê√£ x·∫£y ra l·ªói khi x·ª≠ l√Ω files ho·∫∑c th∆∞ m·ª•c. Vui l√≤ng ki·ªÉm tra console."); addFiles(collectedFiles); } // Try adding whatever was collected
            finally { hideLoading(); }
        };

        const getFilesFromDirectoryHandleRecursive = async (directoryHandle, currentPath, collectedFilesList) => {
            const currentFullPath = `${currentPath}/${directoryHandle.name}`;
            if (isPathIgnored(currentFullPath + '/')) { console.log('Ignored directory contents (picker):', currentFullPath); return; }
            try { const gitignoreHandle = await directoryHandle.getFileHandle('.gitignore', { create: false }); const gitignoreFile = await gitignoreHandle.getFile(); if (await parseGitignore(gitignoreFile)) console.log(`Parsed .gitignore in: ${currentFullPath}`); } catch (e) { /* No .gitignore */ }
            try {
                for await (const entry of directoryHandle.values()) {
                    const entryPath = `${currentFullPath}/${entry.name}`;
                    if (entry.kind === 'directory') await getFilesFromDirectoryHandleRecursive(entry, currentFullPath, collectedFilesList);
                    else if (entry.kind === 'file') {
                        // Add ALL files
                        try { const file = await entry.getFile(); file.relativePath = entryPath; collectedFilesList.push(file); }
                        catch (fileError) { console.error(`Error getting file object for ${entryPath} (picker):`, fileError); }
                    }
                }
            } catch (dirError) { console.error(`Error iterating directory handle ${currentFullPath} (picker):`, dirError); }
        };

        const requestDirectoryAccess = async () => {
            if (!('showDirectoryPicker' in window)) { alert('Tr√¨nh duy·ªát c·ªßa b·∫°n kh√¥ng h·ªó tr·ª£ ch·ªçn th∆∞ m·ª•c. Vui l√≤ng k√©o th·∫£ th∆∞ m·ª•c v√†o ho·∫∑c d√πng tr√¨nh duy·ªát Chrome/Edge m·ªõi nh·∫•t.'); return; }
            try {
                showLoading('ƒêang ch·ªù ch·ªçn th∆∞ m·ª•c...'); const directoryHandle = await window.showDirectoryPicker(); showLoading('ƒêang qu√©t th∆∞ m·ª•c...');
                gitignoreRules = []; gitignoreFound = false; rootPath = '/' + directoryHandle.name;
                let collectedFiles = [];
                try { const gitignoreHandle = await directoryHandle.getFileHandle('.gitignore', { create: false }); const gitignoreFile = await gitignoreHandle.getFile(); await parseGitignore(gitignoreFile); } catch (e) { console.log('Kh√¥ng t√¨m th·∫•y .gitignore ·ªü th∆∞ m·ª•c g·ªëc ƒë√£ ch·ªçn (picker).'); }
                await getFilesFromDirectoryHandleRecursive(directoryHandle, '', collectedFiles);
                showLoading(`ƒê√£ qu√©t xong. ƒêang x·ª≠ l√Ω ${collectedFiles.length} file...`); // Adjusted count message
                addFiles(collectedFiles);
            } catch (err) {
                if (err.name !== 'AbortError') { console.error('L·ªói khi truy c·∫≠p th∆∞ m·ª•c (picker):', err); alert(`L·ªói khi truy c·∫≠p th∆∞ m·ª•c: ${err.message}`); }
                else console.log('Ng∆∞·ªùi d√πng ƒë√£ h·ªßy ch·ªçn th∆∞ m·ª•c.');
            } finally { hideLoading(); }
        };

        // --- Core File Handling Logic ---
        const addFiles = (newFiles) => {
            // This function now receives ALL files discovered
            if (!Array.isArray(newFiles) || newFiles.length === 0) { console.log("addFiles: No valid new files provided."); updateStats(); hideLoading(); return; }
            const uniqueNewFiles = []; const existingPaths = new Set(files.map(f => f.relativePath || f.name));
            for (const file of newFiles) {
                if (!file || !(file instanceof File) || !(file.relativePath || file.name)) { console.warn("Skipping invalid file object:", file); continue; }
                const pathKey = file.relativePath || file.name;
                // Add unique files based on path, regardless of type/ignore status
                if (!existingPaths.has(pathKey)) {
                    // Exclude .gitignore itself from the list unless specifically requested
                    if (file.name !== '.gitignore') {
                        uniqueNewFiles.push(file);
                        existingPaths.add(pathKey);
                    }
                }
            }
            if (uniqueNewFiles.length > 0) {
                files = [...files, ...uniqueNewFiles];
                files.sort((a, b) => (a.relativePath || a.name).localeCompare(b.relativePath || b.name, undefined, { numeric: true, sensitivity: 'base' }));
                displayFileList(); // Update UI list (will show all files)
                readFilesContent(); // Generate output (will handle skipping)
            } else { console.log("No new unique files to add."); updateStats(); hideLoading(); }
        };

        const removeFile = (index) => {
            if (index >= 0 && index < files.length) { const removedFile = files.splice(index, 1)[0]; console.log(`Removed file: ${removedFile.relativePath || removedFile.name}`); displayFileList(); readFilesContent(); }
        };

        // --- UPDATED readFilesContent ---
        const readFilesContent = async () => {
            textContent.value = ''; // Clear previous content
            if (files.length === 0) {
                updateStats(); hideLoading(); return;
            }

            showLoading(`ƒêang x·ª≠ l√Ω ${files.length} file...`);
            let combinedContent = '';
            let readCount = 0;
            const totalFiles = files.length;
            const readPromises = []; // Store promises for reading text files

            for (const file of files) {
                readCount++;
                const displayPath = file.relativePath ? file.relativePath.replace(/^\//, '') : file.name;
                loadingStatus.textContent = `ƒêang x·ª≠ l√Ω file ${readCount}/${totalFiles}: ${displayPath}`;

                const isText = isTextFile(file);
                const isIgnored = isPathIgnored(file.relativePath);

                if (isText && !isIgnored) {
                    // If it's a text file and not ignored, schedule it for reading
                    readPromises.push(
                        readFileAsync(file)
                            .then(content => {
                                // Prepend content for this file to an array to maintain order later
                                return { path: displayPath, content: `/* ===== ${displayPath} ===== */\n${content}\n\n` };
                            })
                            .catch(error => {
                                console.error(`L·ªói khi ƒë·ªçc file ${displayPath}:`, error);
                                // Return error information to be included in order
                                return { path: displayPath, content: `/* ===== ERROR: Kh√¥ng th·ªÉ ƒë·ªçc file: ${displayPath} ===== */\n/* ${error.message} */\n\n` };
                            })
                    );
                } else {
                    // If skipped (non-text or ignored), create a placeholder promise that resolves immediately
                    // This ensures its position is maintained relative to async reads
                    let reason = isIgnored ? "B·ªã lo·∫°i (Ignored)" : "Kh√¥ng ph·∫£i file text";
                    if (isIgnored && !isText) reason = "B·ªã lo·∫°i & Kh√¥ng ph·∫£i text"; // Both conditions

                    readPromises.push(Promise.resolve({
                        path: displayPath,
                        content: `/* --- B·ªè qua (${reason}): ${displayPath} --- */\n\n`
                    }));
                }
                // Optional yield
                // if (readCount % 50 === 0) await new Promise(resolve => setTimeout(resolve, 0));
            }

            try {
                // Wait for all promises (reading text files and placeholders for skipped files)
                const results = await Promise.all(readPromises);

                // Sort results based on the original file order (important!)
                // Create a map for quick lookup
                const fileOrderMap = new Map(files.map((file, index) => [(file.relativePath || file.name), index]));
                results.sort((a, b) => {
                    const pathA = a.path.startsWith('/') ? a.path : '/' + a.path; // Ensure consistent leading slash for map lookup
                    const pathB = b.path.startsWith('/') ? b.path : '/' + b.path;
                    return fileOrderMap.get(pathA) - fileOrderMap.get(pathB);
                });


                // Combine content in the correct order
                combinedContent = results.map(r => r.content).join('');
                textContent.value = combinedContent;

            } catch (error) {
                console.error("Error processing file results:", error);
                alert("ƒê√£ x·∫£y ra l·ªói khi x·ª≠ l√Ω k·∫øt qu·∫£ ƒë·ªçc file.");
                // Show whatever content was generated before the error
                textContent.value = combinedContent;
            } finally {
                updateStats(); // Update stats after processing
                hideLoading(); // Hide loading overlay
            }
        };
        // --- End of UPDATED readFilesContent ---


        // --- UI Updates ---
        const updateStats = () => {
            // Stats now reflect the total number of files listed, including skipped ones
            const totalSize = files.reduce((sum, file) => sum + (file?.size || 0), 0);
            const charCount = textContent.value.length;
            const gitignoreStatus = gitignoreFound ? ` | .gitignore: C√≥ (${gitignoreRules.length} quy t·∫Øc)` : '';
            stats.textContent = `Files: ${files.length} | T·ªïng k√≠ch th∆∞·ªõc: ${formatFileSize(totalSize)} | Context: ${charCount.toLocaleString()} k√Ω t·ª±${gitignoreStatus}`;
        };

        // --- UPDATED displayFileList ---
        const displayFileList = () => {
            fileList.innerHTML = ''; // Clear existing list
            if (files.length === 0) {
                fileList.innerHTML = '<p class="text-gray-500 text-sm italic">Ch∆∞a c√≥ file n√†o ƒë∆∞·ª£c ch·ªçn.</p>';
                dropAreaContent.classList.remove('hidden'); // Show initial prompt
            } else {
                dropAreaContent.classList.add('hidden'); // Hide initial prompt
                files.forEach((file, index) => {
                    const fileItem = document.createElement('div');
                    // Base classes
                    fileItem.className = 'file-item flex justify-between items-center bg-gray-100 p-2 rounded mb-2 text-sm transition-opacity duration-200';

                    const isText = isTextFile(file);
                    const isIgnored = isPathIgnored(file.relativePath);
                    const willBeSkipped = !isText || isIgnored;

                    // Add visual indication if the file will be skipped in the output
                    let skipReason = '';
                    if (willBeSkipped) {
                        fileItem.classList.add('opacity-60'); // Make it slightly transparent
                        if (isIgnored) skipReason = "B·ªã lo·∫°i b·ªüi ignore rule";
                        if (!isText) skipReason += (skipReason ? " & " : "") + "Kh√¥ng ph·∫£i file text";
                        fileItem.title = `File n√†y s·∫Ω ƒë∆∞·ª£c b·ªè qua (${skipReason})`;
                    }

                    const fileInfo = document.createElement('div');
                    fileInfo.className = 'file-info overflow-hidden mr-2';

                    const displayName = file.relativePath ? file.relativePath.replace(/^\//, '') : file.name;

                    fileInfo.innerHTML = `
                        <div class="file-name font-medium text-gray-800 whitespace-nowrap overflow-hidden text-ellipsis" title="${displayName}${willBeSkipped ? ` (${skipReason})` : ''}">${displayName}</div>
                        <div class="file-size text-xs text-gray-500">${formatFileSize(file.size || 0)}</div>
                    `;

                    const removeButton = document.createElement('button');
                    removeButton.innerHTML = '‚úï';
                    removeButton.className = 'remove-btn flex-shrink-0 bg-red-500 hover:bg-red-600 text-white text-xs font-bold w-5 h-5 rounded-full flex items-center justify-center transition duration-200';
                    removeButton.title = `X√≥a file ${displayName}`;
                    removeButton.onclick = (e) => { e.stopPropagation(); removeFile(index); };

                    fileItem.appendChild(fileInfo);
                    fileItem.appendChild(removeButton);
                    fileList.appendChild(fileItem);
                });
            }
            updateStats(); // Update stats whenever the list changes
        };
        // --- End of UPDATED displayFileList ---


        const showLoading = (statusText = 'ƒêang x·ª≠ l√Ω...') => { loadingStatus.textContent = statusText; loading.classList.remove('hidden'); loading.classList.add('flex'); };
        const hideLoading = () => { loading.classList.add('hidden'); loading.classList.remove('flex'); loadingStatus.textContent = ''; };

        // --- Clipboard and Copy ---
        const showCopySuccess = (success = true) => { if (success) { copySuccess.classList.add('opacity-100'); copySuccess.classList.remove('opacity-0'); setTimeout(() => { copySuccess.classList.remove('opacity-100'); copySuccess.classList.add('opacity-0'); }, 2000); } else { alert("Kh√¥ng th·ªÉ sao ch√©p n·ªôi dung v√†o clipboard. Tr√¨nh duy·ªát c·ªßa b·∫°n c√≥ th·ªÉ kh√¥ng h·ªó tr·ª£ ho·∫∑c c·∫ßn c·∫•p quy·ªÅn."); } };
        const fallbackCopy = (textToCopy) => { const textArea = document.createElement('textarea'); textArea.value = textToCopy; textArea.style.position = 'fixed'; textArea.style.top = '-9999px'; textArea.style.left = '-9999px'; textArea.style.opacity = '0'; document.body.appendChild(textArea); textArea.focus(); textArea.select(); let successful = false; try { successful = document.execCommand('copy'); } catch (err) { console.error('L·ªói fallback copy:', err); successful = false; } document.body.removeChild(textArea); showCopySuccess(successful); };
        const copyContentToClipboard = async () => { const content = textContent.value; if (!content) { alert("Kh√¥ng c√≥ n·ªôi dung ƒë·ªÉ sao ch√©p."); return; } if (navigator.clipboard && window.isSecureContext) { try { await navigator.clipboard.writeText(content); showCopySuccess(true); } catch (err) { console.error('L·ªói khi sao ch√©p b·∫±ng Clipboard API:', err); fallbackCopy(content); } } else { console.warn('Clipboard API kh√¥ng kh·∫£ d·ª•ng, s·ª≠ d·ª•ng fallback.'); fallbackCopy(content); } };

        // --- UPDATED handlePaste ---
        const handlePaste = async (e) => {
            if (e.target === textContent) { setTimeout(updateStats, 50); return; }
            e.preventDefault(); console.log("Paste event detected on document."); const clipboardData = e.clipboardData; if (!clipboardData) { console.log("Kh√¥ng c√≥ d·ªØ li·ªáu clipboard."); return; }

            // Collect ALL files/items first
            let potentialFiles = [];
            if (clipboardData.items && clipboardData.items.length > 0) {
                console.log(`ƒêang x·ª≠ l√Ω ${clipboardData.items.length} item t·ª´ clipboard...`);
                const filePromises = Array.from(clipboardData.items)
                    .filter(item => item.kind === 'file')
                    .map(item => item.getAsFile()); // Get File objects if possible
                potentialFiles = (await Promise.all(filePromises)).filter(file => file !== null); // Filter out nulls if getAsFile fails
                potentialFiles.forEach(file => file.relativePath = '/' + file.name); // Assign basic path

                // If no files from items, check text
                if (potentialFiles.length === 0 && clipboardData.types.includes('text/plain')) {
                    const pastedText = clipboardData.getData('text/plain');
                    if (pastedText) {
                        const blob = new Blob([pastedText], { type: 'text/plain' });
                        const pastedFile = new File([blob], `pasted_text_${Date.now()}.txt`, { type: 'text/plain' });
                        pastedFile.relativePath = '/' + pastedFile.name;
                        potentialFiles.push(pastedFile);
                    }
                }
            } else if (clipboardData.files && clipboardData.files.length > 0) { // Fallback to clipboardData.files
                console.log(`ƒêang x·ª≠ l√Ω ${clipboardData.files.length} file t·ª´ clipboard (fallback)...`);
                potentialFiles = Array.from(clipboardData.files);
                potentialFiles.forEach(file => file.relativePath = '/' + file.name);
            } else if (clipboardData.types.includes('text/plain')) { // Fallback to text only
                console.log("ƒêang x·ª≠ l√Ω text t·ª´ clipboard (fallback)...");
                const pastedText = clipboardData.getData('text/plain');
                if (pastedText) {
                    const blob = new Blob([pastedText], { type: 'text/plain' });
                    const pastedFile = new File([blob], `pasted_text_${Date.now()}.txt`, { type: 'text/plain' });
                    pastedFile.relativePath = '/' + pastedFile.name;
                    potentialFiles.push(pastedFile);
                }
            }

            if (potentialFiles.length > 0) {
                showLoading(`ƒêang x·ª≠ l√Ω ${potentialFiles.length} m·ª•c t·ª´ clipboard...`);
                addFiles(potentialFiles); // Add all collected files
            } else {
                console.log("Kh√¥ng t√¨m th·∫•y n·ªôi dung file ho·∫∑c text h·ª£p l·ªá trong clipboard.");
                hideLoading();
            }
        };
        // --- End of UPDATED handlePaste ---


        // --- Event Listeners ---
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => dropArea.addEventListener(eventName, preventDefaults, false));
        ['dragover', 'drop'].forEach(eventName => document.body.addEventListener(eventName, preventDefaults, false));
        ['dragenter', 'dragover'].forEach(eventName => dropArea.addEventListener(eventName, highlight, false));
        ['dragleave', 'drop'].forEach(eventName => dropArea.addEventListener(eventName, unhighlight, false));

        // --- UPDATED Drop Handler ---
        dropArea.addEventListener('drop', async (e) => {
            unhighlight(); const dt = e.dataTransfer; if (!dt) return;
            // Prioritize items API for folder structure
            if (dt.items && dt.items.length > 0 && typeof dt.items[0].webkitGetAsEntry === 'function') {
                await handleDropWithItems(dt.items);
            } else if (dt.files && dt.files.length > 0) { // Fallback to files API
                showLoading(`ƒêang x·ª≠ l√Ω ${dt.files.length} file...`);
                const droppedFiles = Array.from(dt.files);
                droppedFiles.forEach(file => file.relativePath = '/' + file.name); // Assign basic path
                addFiles(droppedFiles); // Add all dropped files
            } else { console.log("Kh√¥ng t√¨m th·∫•y files ho·∫∑c items h·ª£p l·ªá trong s·ª± ki·ªán drop."); hideLoading(); }
        }, false);
        // --- End of UPDATED Drop Handler ---


        // --- UPDATED File Input Handler ---
        fileInput.addEventListener('change', (e) => {
            if (e.target.files && e.target.files.length > 0) {
                showLoading(`ƒêang x·ª≠ l√Ω ${e.target.files.length} file ƒë√£ ch·ªçn...`);
                const selectedFiles = Array.from(e.target.files);
                selectedFiles.forEach(file => { file.relativePath = file.webkitRelativePath ? '/' + file.webkitRelativePath : '/' + file.name; });
                addFiles(selectedFiles); // Add all selected files
            }
            e.target.value = null;
        });
        // --- End of UPDATED File Input Handler ---

        clearBtn.addEventListener('click', () => { files = []; gitignoreRules = []; gitignoreFound = false; rootPath = ''; textContent.value = ''; displayFileList(); console.log("ƒê√£ x√≥a t·∫•t c·∫£ files v√† n·ªôi dung."); });
        copyBtn.addEventListener('click', copyContentToClipboard);
        document.addEventListener('paste', handlePaste);

        // --- Initial Setup ---
        displayFileList();
        hideLoading();

    </script>
</body>

</html>